@using Gastos.Pwa.Shared.Services
@inject PwaUpdateService PwaUpdateService
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar
@implements IDisposable

@if (showUpdateNotification)
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="mb-3">
        <div class="d-flex align-items-center justify-content-between">
            <div class="d-flex align-items-center">
                <MudIcon Icon="@Icons.Material.Filled.SystemUpdate" Class="me-2" />
                <div>
                    <MudText Typo="Typo.body1"><strong>Nueva versión disponible</strong></MudText>
                    <MudText Typo="Typo.body2">Se ha descargado una nueva versión de la aplicación. Actualizar ahora para obtener las últimas mejoras.</MudText>
                </div>
            </div>
            <div class="d-flex gap-2">
                <MudButton Variant="Variant.Text" 
                          Color="Color.Inherit" 
                          Size="Size.Small"
                          OnClick="DismissUpdate">
                    Más tarde
                </MudButton>
                <MudButton Variant="Variant.Filled" 
                          Color="Color.Primary" 
                          Size="Size.Small"
                          StartIcon="@Icons.Material.Filled.Refresh"
                          OnClick="ApplyUpdate"
                          Disabled="isUpdating">
                    @if (isUpdating)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-1" />
                        <span>Actualizando...</span>
                    }
                    else
                    {
                        <span>Actualizar ahora</span>
                    }
                </MudButton>
            </div>
        </div>
    </MudAlert>
}

@if (showForceUpdateButton && !showUpdateNotification)
{
    <MudAlert Severity="Severity.Warning" Variant="Variant.Text" Class="mb-3">
        <div class="d-flex align-items-center justify-content-between">
            <div class="d-flex align-items-center">
                <MudIcon Icon="@Icons.Material.Filled.Warning" Class="me-2" />
                <div>
                    <MudText Typo="Typo.body2">¿La aplicación no se está actualizando correctamente?</MudText>
                </div>
            </div>
            <MudButton Variant="Variant.Text" 
                      Color="Color.Warning" 
                      Size="Size.Small"
                      StartIcon="@Icons.Material.Filled.Cached"
                      OnClick="ForceRefresh">
                Forzar actualización
            </MudButton>
        </div>
    </MudAlert>
}

@code {
    private bool showUpdateNotification = false;
    private bool showForceUpdateButton = false;
    private bool isUpdating = false;
    private Timer? checkTimer;
    private Timer? forceButtonTimer;
    private int updateCheckCount = 0;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            PwaUpdateService.UpdateAvailable += OnUpdateAvailable;
            PwaUpdateService.UpdateInstalled += OnUpdateInstalled;
            PwaUpdateService.UpdateReady += OnUpdateReady;
            
            await PwaUpdateService.InitializeAsync();
            
            // Verificar actualizaciones al inicializar
            _ = Task.Run(async () =>
            {
                await Task.Delay(2000); // Esperar 2 segundos antes de la primera verificación
                await CheckForUpdatesInternal();
            });

            // Configurar timer para verificaciones periódicas
            checkTimer = new Timer(async _ =>
            {
                await CheckForUpdatesInternal();
            }, null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));

            // Mostrar botón de fuerza actualización después de un tiempo si no hay actualizaciones
            forceButtonTimer = new Timer(_ =>
            {
                if (!showUpdateNotification && updateCheckCount > 2)
                {
                    InvokeAsync(() =>
                    {
                        showForceUpdateButton = true;
                        StateHasChanged();
                    });
                }
            }, null, TimeSpan.FromMinutes(15), TimeSpan.FromMinutes(15));
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing PWA update component: {ex.Message}");
        }
    }

    private async Task CheckForUpdatesInternal()
    {
        updateCheckCount++;
        await PwaUpdateService.CheckForUpdatesAsync();
    }

    private async Task OnUpdateAvailable()
    {
        await InvokeAsync(() =>
        {
            showUpdateNotification = true;
            showForceUpdateButton = false;
            StateHasChanged();
            
            // Mostrar snackbar de notificación
            Snackbar.Add("Nueva versión disponible para descargar", Severity.Info, config =>
            {
                config.Icon = Icons.Material.Filled.SystemUpdate;
                config.VisibleStateDuration = 5000;
            });
        });
    }

    private async Task OnUpdateInstalled()
    {
        await InvokeAsync(() =>
        {
            Snackbar.Add("Nueva versión instalada correctamente", Severity.Success, config =>
            {
                config.Icon = Icons.Material.Filled.CheckCircle;
                config.VisibleStateDuration = 3000;
            });
        });
    }

    private async Task OnUpdateReady()
    {
        await InvokeAsync(() =>
        {
            showUpdateNotification = false;
            StateHasChanged();
            
            Snackbar.Add("Aplicación actualizada y lista", Severity.Success, config =>
            {
                config.Icon = Icons.Material.Filled.CheckCircle;
                config.VisibleStateDuration = 3000;
            });
        });
    }

    private async Task ApplyUpdate()
    {
        try
        {
            isUpdating = true;
            StateHasChanged();
            
            Snackbar.Add("Aplicando actualización...", Severity.Info, config =>
            {
                config.Icon = Icons.Material.Filled.HourglassEmpty;
                config.VisibleStateDuration = 2000;
            });

            await PwaUpdateService.SkipWaitingAsync();
            
            // Esperar un poco antes de recargar para que se complete la activación
            await Task.Delay(1500);
            
            await PwaUpdateService.ReloadAppAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying update: {ex.Message}");
            
            isUpdating = false;
            StateHasChanged();
            
            Snackbar.Add("Error al aplicar la actualización", Severity.Error, config =>
            {
                config.Icon = Icons.Material.Filled.Error;
                config.VisibleStateDuration = 5000;
            });
        }
    }

    private void DismissUpdate()
    {
        showUpdateNotification = false;
        StateHasChanged();
        
        Snackbar.Add("Recordatorio: Actualización disponible", Severity.Info, config =>
        {
            config.Icon = Icons.Material.Filled.Schedule;
            config.VisibleStateDuration = 3000;
        });
        
        // Volver a mostrar la notificación después de 10 minutos
        _ = Task.Delay(TimeSpan.FromMinutes(10)).ContinueWith(_ =>
        {
            InvokeAsync(() =>
            {
                showUpdateNotification = true;
                StateHasChanged();
            });
        });
    }

    private async Task ForceRefresh()
    {
        try
        {
            showForceUpdateButton = false;
            StateHasChanged();

            Snackbar.Add("Limpiando cache y actualizando...", Severity.Warning, config =>
            {
                config.Icon = Icons.Material.Filled.CleaningServices;
                config.VisibleStateDuration = 3000;
            });

            // Limpiar todos los caches y recargar
            await JSRuntime.InvokeVoidAsync("eval", @"
                if (window.pwaUpdater && window.pwaUpdater.clearAllCaches) {
                    window.pwaUpdater.clearAllCaches();
                } else {
                    // Fallback manual
                    if ('caches' in window) {
                        caches.keys().then(function(names) {
                            names.forEach(function(name) {
                                caches.delete(name);
                            });
                        }).then(function() {
                            window.location.reload(true);
                        });
                    } else {
                        window.location.reload(true);
                    }
                }
            ");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error forcing refresh: {ex.Message}");
            
            Snackbar.Add("Error al forzar actualización", Severity.Error, config =>
            {
                config.Icon = Icons.Material.Filled.Error;
                config.VisibleStateDuration = 5000;
            });
        }
    }

    public void Dispose()
    {
        if (PwaUpdateService != null)
        {
            PwaUpdateService.UpdateAvailable -= OnUpdateAvailable;
            PwaUpdateService.UpdateInstalled -= OnUpdateInstalled;
            PwaUpdateService.UpdateReady -= OnUpdateReady;
        }
        
        checkTimer?.Dispose();
        forceButtonTimer?.Dispose();
    }
}