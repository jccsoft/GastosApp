@inject IJSRuntime _jsRuntime
@inject ISnackbar Snackbar
@inject BlazorService BlazorService

@code {
    protected override async Task OnInitializedAsync()
    {
        await BlazorService.BrowserLogAsync($"UpdateAvailableDetector: OnInitializedAsync");
        await RegisterForUpdateAvailableNotification();
    }

    private async Task RegisterForUpdateAvailableNotification()
    {
        await BlazorService.BrowserLogAsync($"UpdateAvailableDetector: RegisterForUpdateAvailableNotification");
        
        // Usar el sistema pwa-updater más robusto
        await _jsRuntime.InvokeVoidAsync("pwaUpdater.initialize", DotNetObjectReference.Create(this));
    }

    [JSInvokable]
    public async Task OnUpdateAvailable()
    {
        await BlazorService.BrowserLogAsync($"UpdateAvailableDetector: OnUpdateAvailable");
        ShowUpdateNotification();
    }

    [JSInvokable]
    public async Task OnUpdateReady()
    {
        await BlazorService.BrowserLogAsync($"UpdateAvailableDetector: OnUpdateReady");
        ShowUpdateNotification();
    }

    [JSInvokable]
    public async Task OnUpdateInstalled()
    {
        await BlazorService.BrowserLogAsync($"UpdateAvailableDetector: OnUpdateInstalled");
        // Opcional: mostrar notificación de instalación exitosa
    }

    private void ShowUpdateNotification()
    {
        Snackbar.Configuration.PositionClass = Defaults.Classes.Position.BottomCenter;

        Snackbar.Add(new MarkupString("<center><p class='p-0 m-0'>NUEVA VERSIÓN DISPONIBLE.</p><p class='p-0 m-0'>HAGA CLIC AQUÍ PARA ACTUALIZAR.</p></center>"),
            Severity.Warning,
            config =>
            {
                config.RequireInteraction = true;
                config.ShowCloseIcon = true;
                config.HideIcon = true;
                config.OnClick = snackbar =>
                {
                    // Usar el método más robusto del pwa-updater
                    _jsRuntime.InvokeVoidAsync("pwaUpdater.skipWaiting");
                    StateHasChanged();
                    return Task.CompletedTask;
                };
            });
    }
}