@implements IDisposable
@inject IJSRuntime JSRuntime

@inject BlazorService BlazorService
@inject IDocIntelApi DocIntelApi
@inject IReceiptApi ReceiptApi
@inject ISnackbar Snackbar
@inject LocalizationService Loc
@inject StateContainer StateContainer


@if (!string.IsNullOrEmpty(_errorMessage))
{
    <Alert Message="@_errorMessage" />
}
else if(_analysisJobs is null)
{
    <Loading Class="mt-4" />
}
else if (_analysisJobs.ItemsCount == 0)
{
    <Alert Message="@Loc.Get(RS.ErrorNoPendingReceipts)" Severity="Severity.Info" />
}
else
{
    <MudStack Row Justify="Justify.SpaceBetween">
        <MudText Typo="Typo.h6">@($"{Loc.Get(RS.PendingReceipts)}:")</MudText>
        <MyButton Type="IconRefresh" OnClick="RefreshAnalysisJobsAsync" Disabled="@_checkingStatus" />
    </MudStack>

    <MudGrid Spacing="5">
        @foreach (var job in _analysisJobs.Items.OrderBy(j => j.CreatedAtUtc))
        {
            <MudItem xs="12" sm="4">
                <AnalysisJobCard @key="job.Id" Job="@job"
                                 OnCreateClick="() => OpenCreateReceiptDialogAsync(job.Id, job.DocumentId, job.FileName)"
                                 OnDeleteClick="() => DeleteAnalysisJobAsync(job.Id, job.FileName)" />
            </MudItem>
        }
    </MudGrid>
}


@code {
    private PendingJobCollection? _analysisJobs, _restoredAnalysisJobs;
    private const string LocalStorageKey = "analysisJobs_pending";

    private string? _errorMessage;
    private bool _checkingStatus = false;

    private System.Timers.Timer? _refreshTimer;
    private const int _refreshIntervalMilliseconds = 300;

    protected override void OnInitialized()  
    {    
        StateContainer.AnalysisJobCreated += OnAnalysisJobCreated;  
        StateContainer.BreakpointChanged += OnBreakpointChanged;

        _refreshTimer = new System.Timers.Timer(_refreshIntervalMilliseconds);
        _refreshTimer.Elapsed += TimerElapsed;  
    }  

    protected override async Task OnInitializedAsync()
    {
        _restoredAnalysisJobs = await BlazorService.RestoreDataFromLocalStorageAsync<PendingJobCollection>(LocalStorageKey);

        await FetchPendingAnalysisJobsAsync();
    }

    private async Task FetchPendingAnalysisJobsAsync()
    {
        _refreshTimer?.Stop();

        _analysisJobs = null;

        GetAllAnalysisJobsRequest request = new() { Page = 1, PageSize = 100 };

        try
        {
            var response = await DocIntelApi.GetAllAnalysisJobsAsync(request);

            if (response.IsSuccessStatusCode && response.Content is AnalysisJobCollectionResponse collectionResponse)
            {
                var newJobs = collectionResponse.Items
                    .Select(item => new PendingAnalysisJob(item.Id, item.FileName, item.CreatedAtUtc, item.CompletedAtUtc, item.Status, item.DocumentId, item.Errors))
                    .ToList();

                // Si hay datos restaurados, combinar la información
                if (_restoredAnalysisJobs is not null)
                {
                    var restoredJobsDict = _restoredAnalysisJobs.Items.ToDictionary(j => j.Id, j => j);

                    // Reemplazar cada job nuevo con el restaurado si existe, para mantener el estado UI
                    newJobs = newJobs.Select(job => 
                        restoredJobsDict.TryGetValue(job.Id, out var restoredJob) ? restoredJob : job
                    ).ToList();
                }

                _analysisJobs = new PendingJobCollection
                {
                    Items = newJobs,
                    ItemsCount = collectionResponse.ItemsCount,
                    Page = collectionResponse.Page,
                    PageSize = collectionResponse.PageSize
                };
            }
            else
            {
                _errorMessage = BlazorService.GetResponseError(response);
            }
        }
        catch (Exception ex)
        {
            _errorMessage = BlazorService.GetResponseError(ex);
        }

        StateHasChanged();

        await CheckAnalysisJobsStatus();

        await BlazorService.PersistDataToLocalStorageAsync(LocalStorageKey, _analysisJobs);

        _refreshTimer?.Start();
    }

    private async Task CheckAnalysisJobsStatus()
    {
        if (_analysisJobs is null) return;

        _checkingStatus = true;

        foreach (var job in _analysisJobs.Items.Where(j => j.CheckPending).OrderBy(j => j.CreatedAtUtc))
        {
            var responseJob = await DocIntelApi.GetAnalysisJobByIdAsync(job.Id);
            if (!(responseJob.IsSuccessStatusCode && responseJob.Content is AnalysisJobResponse remoteJob)) continue;

            job.UpdateJobInfo(remoteJob);

            if (!(remoteJob.IsSuccessful && remoteJob.DocumentId is not null)) continue;

            var responseReceipt = await DocIntelApi.GetReceiptByIdAsync((Guid)remoteJob.DocumentId);
            if (responseReceipt.IsSuccessStatusCode && responseReceipt.Content is ReceiptResponse receipt)
            {
                job.UpdateReceiptInfo(receipt);

                if (IsJobReceiptAlreadyPending(job))
                {
                    job.IsReceiptAlreadyPending = true;
                }
                else if (await IsJobReceiptAlreadyCreated(job))
                {
                    job.IsReceiptAlreadyCreated = true;
                } 
            }

            await InvokeAsync(StateHasChanged); 
        }

        _checkingStatus = false;

        await BlazorService.PersistDataToLocalStorageAsync(LocalStorageKey, _analysisJobs);
    }

    private bool IsJobReceiptAlreadyPending(PendingAnalysisJob job)
    {
        if (_analysisJobs is null || string.IsNullOrEmpty(job.ReceiptMerchant) || job.ReceiptTransactionDate is null) return false;

        return _analysisJobs.Items.Any(j =>
            j.CreatedAtUtc <= job.CreatedAtUtc &&
            j.Id != job.Id &&
            j.ReceiptMerchant!.GetFirstWord().Equals(job.ReceiptMerchant, StringComparison.CurrentCultureIgnoreCase) &&
            j.ReceiptTransactionDate == job.ReceiptTransactionDate);
    }

    private async Task<bool> IsJobReceiptAlreadyCreated(PendingAnalysisJob job)
    {
        if (string.IsNullOrEmpty(job.ReceiptMerchant) || job.ReceiptTransactionDate is null) return false;

        var responseExists = await ReceiptApi.ExistsByStoreSourceNameAndDate(
            job.ReceiptMerchant!,
            (DateTime)job.ReceiptTransactionDate);

        return responseExists.IsSuccessStatusCode && responseExists.Content;
    }

    private async void TimerElapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        if (_checkingStatus) return;

        _refreshTimer?.Stop();

        if (_analysisJobs is not null &&
            _analysisJobs.Items.Any(i =>
                i.Status == (int)AnalysisJobStatusResponse.Pending ||
                i.Status == (int)AnalysisJobStatusResponse.InProgress))
        {
            await InvokeAsync(async () => await CheckAnalysisJobsStatus());

            _refreshTimer?.Start();
        }
    }

    private async Task RefreshAnalysisJobsAsync()
    {
        _refreshTimer?.Stop();
        _analysisJobs = null;
        await InvokeAsync(StateHasChanged);
        _restoredAnalysisJobs = null;       
        await FetchPendingAnalysisJobsAsync();
    }

    #region ACTIONS
    private async Task OpenCreateReceiptDialogAsync(Guid analysisJobId, Guid? receiptId, string fileName)
    {
        if (!receiptId.HasValue || receiptId == Guid.Empty)
        {
            Snackbar.Add(Loc.Get(RS.ErrorNoReceiptFoundForAnalysisJob), Severity.Error);
            return;
        }

        var result = await BlazorService.OpenCreateReceiptDialogAsync(receiptId, fileName);
        if (result is not null && !result.Canceled)
        {
            StateHasChanged();

            await DocIntelApi.DeleteAnalysisJobAsync(analysisJobId);

            await FetchPendingAnalysisJobsAsync();
        }
    }

    private async Task DeleteAnalysisJobAsync(Guid jobId, string fileName)
    {
        bool confirmedDeletion = await BlazorService.ConfirmDeletionAsync(
            string.Format(Loc.Get(RS.AskDeleteAnalysisJob0), fileName));

        if (confirmedDeletion)
        {
            var response = await DocIntelApi.DeleteAnalysisJobAsync(jobId);
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add(Loc.Get(RS.SuccessDelete), Severity.Success);
                await FetchPendingAnalysisJobsAsync();
            }
            else
            {
                BlazorService.ShowResponseError(response);
            }
        }
    }

    private async void OnAnalysisJobCreated(List<Guid> jobIds)
    {
        await FetchPendingAnalysisJobsAsync();
    }
    #endregion


    private void OnBreakpointChanged() => StateHasChanged();

    async void IDisposable.Dispose()
    {
        StateContainer.AnalysisJobCreated -= OnAnalysisJobCreated;
        StateContainer.BreakpointChanged -= OnBreakpointChanged;

        _refreshTimer?.Dispose();

        await BlazorService.PersistDataToLocalStorageAsync(LocalStorageKey, _analysisJobs);
    } 
}
