@implements IDisposable

@inject ICameraService CameraService
@inject IDocIntelApi DocIntelApi
@inject ILogger<AnalysisJobsCreation> Logger
@inject ISnackbar Snackbar
@inject LocalizationService Loc
@inject StateContainer StateContainer


<MudPaper Elevation="5" Class="p-3">
    <MudFileUpload T="IReadOnlyList<IBrowserFile>" @ref="@_fileUpload" OnFilesChanged="OnInputFileChanged" AppendMultipleFiles="true"
                   Accept="@(string.Join(',',_acceptedFileExtensions))"
                   Hidden="@false" InputClass="absolute mud-width-full mud-height-full overflow-hidden z-10" InputStyle="opacity:0" tabindex="-1"
                   @ondrop="@ClearDragClass" @ondragenter="@SetDragClass" @ondragleave="@ClearDragClass" @ondragend="@ClearDragClass">
        <ActivatorContent>
            <MudPaper Height="22vh" Outlined="true" Class="@_dragClass">
                <MudStack Justify="Justify.Center" AlignItems="AlignItems.Center" Style="height: 100%; padding: 16px;">
                    <MudChip T="string" Color="Color.Info" Icon="@Icons.Material.Filled.CloudUpload" Class="mt-2"
                             Variant="Variant.Text" Size="@(_selectedFiles.Any() ? Size.Medium: Size.Large)">
                        @Loc.Get(RS.DragFilesHereOrClick)
                    </MudChip>
                    @if (_selectedFiles.Any())
                    {
                        <MudStack Row Wrap="Wrap.Wrap" Justify="Justify.Center" Spacing="1" Class="mt-2">
                            @foreach (var fileName in _selectedFiles.Select(x => x.File.Name))
                            {
                                <MudChip T="string" Color="Color.Dark" Text="@fileName" tabindex="-1" Size="@(StateContainer.IsMobile? Size.Small: Size.Medium)" />
                            }
                        </MudStack>
                    }
                </MudStack>
            </MudPaper>
        </ActivatorContent>
    </MudFileUpload>

    <MudStack Row Class="mt-5"
                Justify="@(_selectedFiles.Any() ? Justify.SpaceBetween: Justify.Center)" 
                AlignItems="AlignItems.Baseline">
        @if (_selectedFiles.Any())
        {
            <MyButton Type="BtnProcessFiles" OnClick="@CreateAnalysisJobsAsync" Disabled="@_processingFiles" />
            <MyButton Type="IconClear" OnClick="@ClearAsync" Disabled="@_processingFiles" />
        }
        else
        {
            <MyButton Type="BtnTakePhoto" OnClick="@OpenPhotoModal" Disabled="@(!_cameraAvailable || _processingFiles)" />
        }
    </MudStack>        

    @if (!_cameraAvailable && _cameraChecked)
    {
        <Alert Message="@Loc.Get(RS.ErrorCameraUnavailable)" Class="mt-2" />
    }
</MudPaper>

<PhotoCaptureModal @bind-IsVisible="@_photoModalVisible" OnPhotoCaptured="@OnPhotoCaptured" />

@code {
    private readonly List<SelectedFile> _selectedFiles = new();
    private sealed record SelectedFile(IBrowserFile File, string IdempotencyKey);
    private readonly List<string> _acceptedFileExtensions = new() { ".png", ".jpg", ".jpeg", ".pdf" };
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string _dragClass = DefaultDragClass;
    private bool _processingFiles = false;

    // Camera related fields
    private bool _photoModalVisible = false;
    private bool _cameraAvailable = false;
    private bool _cameraChecked = false;

    protected override void OnInitialized()
    {
        StateContainer.BreakpointChanged += OnBreakpointChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await CheckCameraAvailability();
        }
    }

    private async Task CheckCameraAvailability()
    {
        try
        {
            var result = await CameraService.IsCameraAvailableAsync();
            _cameraAvailable = result.Available;
            _cameraChecked = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, Loc.Get(RS.ErrorCameraChecking));
            _cameraAvailable = false;
            _cameraChecked = true;
            StateHasChanged();
        }
    }

    private void OpenPhotoModal()
    {
        if (_cameraAvailable)
        {
            _photoModalVisible = true;
        }
        else
        {
            Snackbar.Add(Loc.Get(RS.ErrorCameraUnavailable), Severity.Warning);
        }
    }

    private async Task OnPhotoCaptured(PhotoCapturedEventArgs args)
    {
        try
        {
            // Create a browser file from the captured image data
            var browserFile = new BrowserFileFromStream(args.ImageData, args.FileName, args.MimeType);

            // Add to selected files
            var selectedFile = new SelectedFile(File: browserFile, IdempotencyKey: Guid.NewGuid().ToString());
            _selectedFiles.Add(selectedFile);
            
            await CreateAnalysisJobsAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, Loc.Get(RS.ErrorCameraProcessing));
            Snackbar.Add(Loc.Get(RS.ErrorCameraProcessing), Severity.Error);
        }
    }

    private void OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        var files = e.GetMultipleFiles();
        foreach (var file in files)
        {
            if (!_acceptedFileExtensions.Contains(Path.GetExtension(file.Name).ToLowerInvariant()))
            {
                Snackbar.Add(string.Format(Loc.Get(RS.ErrorFileTypeNotSupported0), file.Name), Severity.Error);
                continue;
            }
            if(_selectedFiles.Any(x => x.File.Name == file.Name))
            {
                Snackbar.Add(string.Format(Loc.Get(RS.ErrorFileAlreadySelected0), file.Name), Severity.Warning);
                continue;
            }

            _selectedFiles.Add(new(File: file, IdempotencyKey: Guid.NewGuid().ToString()));
        }
    }

    private async Task CreateAnalysisJobsAsync()
    {
        try
        {
            _processingFiles = true;
            List<Guid> jobIds = new();

            foreach (var selectedFile in _selectedFiles)
            {
                using var stream = selectedFile.File.OpenReadStream();
                var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var fileBytes = memoryStream.ToArray();

                var apiResponse = await DocIntelApi.CreateAnalysisJobAsync(
                    fileBytes,
                    selectedFile.File.Name,
                    ModelTypes.Receipt,
                    selectedFile.IdempotencyKey);

                if (apiResponse.IsSuccessStatusCode)
                {
                    Snackbar.Add(string.Format(Loc.Get(RS.AnalysisJobCreated), selectedFile.File.Name), Severity.Success);
                    jobIds.Add(apiResponse.Content!.Id);
                }
                else
                {
                    string errorMessage = (apiResponse.GetErrorMessage() ?? apiResponse.Error.ReasonPhrase) ?? Loc.Get(RS.ErrorUnknown);
                    MarkupString message = new($"{string.Format(Loc.Get(RS.ErrorWithFile), selectedFile.File.Name, errorMessage)}<br/>{errorMessage}");
                    Snackbar.Add(message, Severity.Error);
                }
            }
            _processingFiles = false;
            if (jobIds.Any())
            {
                StateContainer.NotifyAnalysisJobCreated(jobIds);
                await ClearAsync();
            }
        }
        catch (Exception ex)
        {
            _processingFiles = false;
            Logger.LogError(ex, "Error creating analysis jobs");
            Snackbar.Add(Loc.Get(RS.ErrorUnknown), Severity.Error);
        }
    }

    private async Task ClearAsync()
    {
        await (_fileUpload?.ClearAsync() ?? Task.CompletedTask);
        _selectedFiles.Clear();
        ClearDragClass();
    }

    private void SetDragClass()
        => _dragClass = $"{DefaultDragClass} mud-border-primary";

    private void ClearDragClass()
        => _dragClass = DefaultDragClass;

    private void OnBreakpointChanged() => StateHasChanged();

    public void Dispose() => StateContainer.BreakpointChanged -= OnBreakpointChanged;
}

